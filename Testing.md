Comprehensive Testing Instructions for Modular Blockchain

Follow these steps carefully to set up and test your multi-node consortium blockchain using the refactored single node file and external configuration.

Step 0: Verify All Files and Directory Structure

Ensure your project directory has the following structure and that all files contain their most up-to-date content as provided in our previous interactions:

consortium-blockchain-project/
├── blockchain_core.py           # (Updated with Wallet and SHA-256: blockchain_core_wallet)
├── common_node_logic.py         # (Updated to load config from file: common_node_logic_config_file)
├── blockchain_node.py           # (The single generic node file: blockchain_node_py)
├── docker-compose.yml           # (Updated for single node file & config mounting: docker_compose_single_node_file)
├── initial_policies.json        # (Initial off-chain policies: initial_policies_json)
├── start.sh                     # (To build and run Docker: start_sh)
└── config/                      # Directory for node-specific configurations
    ├── node1_config.json        # (Config for Node 1: node1_config_json)
    ├── node2_config.json        # (Config for Node 2: node2_config_json)
    ├── node3_config.json        # (Config for Node 3: node3_config_json)
    └── node4_config.json        # (Config for Node 4: node4_config_json)


Key Checks:

blockchain_core.py: Should contain the Wallet class and use hashlib.sha256 for hashing.

common_node_logic.py: The start_node function should accept a config_file_path argument and load the node's settings from there. It should also import and use the Wallet for signing.

blockchain_node.py: This is the file you selected. It should not contain NODE_CONFIG directly, but instead load the config file path from sys.argv[1].

docker-compose.yml: Verify that the command for each service points to python blockchain_node.py and passes the correct config/nodeX_config.json path. Also ensure the volumes section mounts both initial_policies.json and the entire config/ directory.

config/ files: Each nodeX_config.json must have its correct NODE_ID, NODE_PORT, NODE_ENCRYPTION_KEY, and a complete PEERS list containing all other nodes in the network. The POLICY_FILE_PATH should be set to "initial_policies.json" in all of them (even though only Hospital_1 uses it to propose).

Example for node1_config.json Peers:

"PEERS": [
  { "id": "Hospital_2", "address": "http://node2:5002" },
  { "id": "Hospital_3", "address": "http://node3:5003" },
  { "id": "Hospital_4", "address": "http://node4:5004" }
]


Example for node2_config.json Peers:

"PEERS": [
  { "id": "Hospital_1", "address": "http://node1:5001" },
  { "id": "Hospital_3", "address": "http://node3:5003" },
  { "id": "Hospital_4", "address": "http://node4:5004" }
]


(And similarly for Node 3 and Node 4).

Step 1: Build and Run Docker Containers

Open your terminal in the consortium-blockchain-project directory.

Run the start.sh script:

./start.sh


This script will:

Stop and remove any old Docker containers and images.

Build new images using your updated code.

Start node1, node2, node3, and node4.

Observe the logs: In the terminal where docker-compose up is running, you should see:

All four nodes starting up.

Each node creating its Wallet (e.g., "Wallet created for Hospital_1: Public Key: PUBLIC_KEY_Hospital_1_...").

Each node registering its organization with its unique Public Key.

Each node adding itself and its peers as authorized_miners.

Hospital_1 loading policies from initial_policies.json and then proposing them as PolicyUpdate transactions, signing them with its wallet's private key, and broadcasting them.

Background consensus and synchronizer messages appearing every 15 seconds. You will see transactions being added to pending pools, proposals being broadcast, endorsements being made, and blocks being finalized.

Step 2: Initial Status Checks

Open NEW terminal tabs/windows for testing (you'll likely want 4-5 tabs to observe different nodes and send commands).

Check each Node's Status:

curl http://localhost:5001/status
curl http://localhost:5002/status
curl http://localhost:5003/status
curl http://localhost:5004/status


Expected:

"message" should indicate the node is up.

"chain_length" should be 1 (only genesis block so far).

"pending_tx_count" on Node 1 will be 2 initially (for the initial policy transactions), and eventually all nodes will show 2 as they broadcast.

"authorized_miners" should list all four hospitals.

"current_policies" should initially be {} (empty) on all nodes, as policies are not active until mined into a block.

"proposed_blocks_count" might fluctuate as proposals are made and finalized.

"node_public_key" will display the unique public key generated by the wallet for each node.

Check Initial Chains:

curl http://localhost:5001/chain
curl http://localhost:5002/chain
curl http://localhost:5003/chain
curl http://localhost:5004/chain


Expected: All should show only the genesis block.

Check Initial World State:

curl http://localhost:5001/current_state


Expected: {"current_state": {}} (empty).

Step 3: Propose and Endorse a Block (Finalizing Initial Policies)

Now, let's get the initial policies into the blockchain. Since Hospital_1 proposed them, it can propose the first block.

Hospital_1 Proposes the First Block:

Go to your Node 1 terminal or open a new one.

curl http://localhost:5001/propose_block


Expected Logs:

Node 1: "Block #1 proposed by 'Hospital_1'...", then "Block proposed and broadcast for endorsement."

Node 2, 3, 4: "Block proposal received and added to pending proposals." and then "Block '...' endorsed by 'Hospital_X'." (as they automatically endorse).

All Nodes: You will see messages like "Block #1 '...' received enough endorsements..." and "Block #1 successfully added after consensus." This process might take a few seconds due to the background threads and network communication.

Verify Policies are Active and Chain is Updated:

Give it a few seconds for propagation and background consensus to run.

curl http://localhost:5001/chain
# ... check other nodes' chains


Expected: All chains should now show two blocks: the genesis block and Block #1. Block #1 will contain the two PolicyUpdate transactions.

curl http://localhost:5001/status
curl http://localhost:5002/status
curl http://localhost:5003/status
curl http://localhost:5004/status


Expected: "current_policies" on all nodes should now reflect the policies:
{"restrict_sender_to_registered_orgs": true, "min_ventilator_duration_hrs": 1, "authorized_policy_proposers": ["Hospital_1"]}.
This demonstrates on-chain governance successfully, including the policy that defines who can propose policies!

Step 4: Test Regular and Encrypted Transactions (NO MANUAL SIGNATURE IN CURL!)

Create a Regular Transaction (from Hospital 2 - auto-signed by Node 2's wallet):

curl -X POST -H "Content-Type: application/json" -d '{
    "sender": "Hospital_2",
    "recipient": "Hospital_1",
    "amount": 10,
    "data": {"type": "ventilator_log", "patient_id": "P001", "duration_hrs": 24}
    }' http://localhost:5002/transactions/new


Expected Logs: "Transaction added to pending...", then "Broadcasting transaction..." on Node 2. Other nodes will receive it. Node 2's logs will show "Transaction signed by Hospital_2. Simulated Signature:..."

Create an ENCRYPTED Transaction (from Hospital 3 - auto-signed by Node 3's wallet):

Simulate encryption (as before, you'd do this in your client app):
Example: simulate_encrypt(json.dumps({"type": "patient_lab_results", "patient_id": "P004", "results": "Normal"}), "Hospital_3_ENC_Key")
Yields something like: ENC:Hospital_3_ENC_Key:eyJ0eXBlIjogInBhdGllbnRfbGFiX3Jlc3VsdHMiLCAicGF0aWVudF9pZCI6ICJQMDA0IiwgInJlc3VsdHMiOiAiTm9ybWFsIn0=

curl -X POST -H "Content-Type: application/json" -d '{
    "sender": "Hospital_3",
    "recipient": "Hospital_4",
    "amount": 5,
    "data": "ENC:Hospital_3_ENC_Key:eyJ0eXBlIjogInBhdGllbnRfbGFiX3Jlc3VsdHMiLCAicGF0aWVudF9pZCI6ICJQMDA0IiwgInJlc3VsdHMiOiAiTm9ybWFsIn0=",
    "is_encrypted": true
}' http://localhost:5003/transactions/new


Expected Logs: Similar transaction added and broadcast messages. Node 3's logs will show "Transaction signed by Hospital_3. Simulated Signature:..."

Check Pending Transactions (all nodes):

curl http://localhost:5001/pending_transactions
# ... check other nodes


Expected: All nodes should now have both transactions in their pending pool, including the new signature field (a SHA-256 hash).

Step 5: Propose and Endorse Another Block (Updating World State)

Let's have Node 4 propose the next block.

Hospital_4 Proposes Block:

curl http://localhost:5004/propose_block


Expected Logs:

Node 4: "Block #2 proposed by 'Hospital_4'...", then broadcast.

Node 1, 2, 3: Receive proposal, add to proposed pool, automatically endorse, and broadcast endorsement.

All Nodes: Eventually, "Block #2 '...' received enough endorsements...", then "Block #2 successfully added after consensus."

Verify Chains and World State:

Give it a few seconds for consensus.

curl http://localhost:5001/chain
# ... check other nodes' chains


Expected: All chains should now have 3 blocks. Block #2 will contain the two transactions.

curl http://localhost:5001/current_state
# ... check other nodes' states


Expected: The current_state on all nodes should now reflect the changes from the ventilator_log transaction.

Step 6: Test Data Decryption (Same as Before)

Identify Encrypted Transaction Hash:

Use curl http://localhost:5003/chain to view the chain data on Node 3. Find Block #2 (index 2). Locate the transaction from Hospital_3 to Hospital_4 with is_encrypted: true. Copy its calculate_hash() value (this is the tx_hash).

Attempt Decryption from Node 3 (which has the key):

Replace TX_HASH_OF_ENCRYPTED_TX with the actual hash you copied.

curl "http://localhost:5003/transaction/decrypt?block_index=2&tx_hash=TX_HASH_OF_ENCRYPTED_TX"


Expected: Successful decryption.

Attempt Decryption from Node 1 (which does NOT have Node 3's key):

Use the same TX_HASH_OF_ENCRYPTED_TX.

curl "http://localhost:5001/transaction/decrypt?block_index=2&tx_hash=TX_HASH_OF_ENCRYPTED_TX"


Expected: Decryption failure message, demonstrating restricted access.

Step 7: Test Policy Enforcement (On-Chain Governance)

Try to Send an Unauthorized Transaction (should fail due to policy):

curl -X POST -H "Content-Type: application/json" -d '{
    "sender": "Unauthorized_Org",
    "recipient": "Hospital_1",
    "amount": 1,
    "data": {"type": "test_unauth"}
    }' http://localhost:5001/transactions/new


Expected: Policy Violation message (Policy Violation: Sender 'Unauthorized_Org' is not a registered organization or has no public key.).

Try to Propose a Policy from an Unauthorized Node (e.g., Hospital_2):

Attempt to propose a new policy from Hospital_2. Remember that initial_policies.json sets Hospital_1 as the authorized_policy_proposers.

curl -X POST -H "Content-Type: application/json" -d '{
    "policy_name": "new_unauth_policy",
    "policy_value": "test_value"
}' http://localhost:5002/policy/propose


Expected: Node 2 logs will show "Policy Violation: Sender 'Hospital_2' is not an authorized policy proposer." The API response will be {"message": "Invalid transaction."}. This confirms the on-chain policy enforcement.

This detailed testing process should confirm that your modular consortium blockchain is functioning correctly with all its new features.