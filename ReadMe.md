Comprehensive Testing Instructions for Wallet-Integrated Blockchain

Follow these steps carefully to set up and test your multi-node consortium blockchain with the new Wallet and refined signature mechanism.

Step 0: Update Files

Update blockchain_core.py: Save the content of blockchain_core_wallet into your blockchain_core.py file.

Update common_node_logic.py: Save the content of common_node_logic_wallet into your common_node_logic.py file.

Update your nodeX.py files:

For each of node1.py, node2.py, node3.py, and node4.py, replace their entire content with the template from nodeX_template_final.

CRITICALLY, adjust the NODE_CONFIG dictionary in each nodeX.py file:

Set NODE_PORT (5001, 5002, 5003, 5004).

Set NODE_ID (Hospital_1, Hospital_2, Hospital_3, Hospital_4).

Remove NODE_PRIVATE_KEY from the NODE_CONFIG dictionary. The Wallet now generates and manages this.

Set NODE_ENCRYPTION_KEY (e.g., "Hospital_1_ENC_Key").

Ensure PEERS lists are comprehensive for all 4 nodes, as defined in all_peers_config from earlier.

Verify docker-compose.yml: Ensure it's still configured for all four nodes as per docker_compose_updated.

Step 1: Build and Run Docker Containers

Open your terminal in the consortium-blockchain-project directory.

Run the start.sh script:

./start.sh


Observe the logs:

You should see all nodes starting, creating wallets (Wallet created for Hospital_X...), registering organizations with their Public Keys, and authorizing miners.

Hospital_1 will propose the initial policy transactions.

You'll see SHA-256 hashes in the logs (much longer strings).

Step 2: Initial Status Checks

Open NEW terminal tabs/windows (4-5 tabs recommended).

Check each Node's Status:

curl http://localhost:5001/status
curl http://localhost:5002/status
curl http://localhost:5003/status
curl http://localhost:5004/status


Expected:

"message" should indicate the node is up.

"chain_length" should be 1.

"pending_tx_count" on Node 1 will be 2 initially.

"authorized_miners" should list all four hospitals.

"current_policies" should initially be {}.

"proposed_blocks_count" should be 0.

NEW: "node_public_key" will display the unique public key generated by the wallet for each node.

Step 3: Propose and Endorse a Block (Finalizing Initial Policies)

Hospital_1 Proposes the First Block:

Go to your Node 1 terminal or open a new one.

curl http://localhost:5001/propose_block


Expected Logs:

Node 1: "Block #1 proposed by 'Hospital_1'...", then broadcast.

Node 2, 3, 4: "Block proposal received and added to pending proposals." and then "Block '...' endorsed by 'Hospital_X'."

All Nodes: Eventually, "Block #1 '...' received enough endorsements..." and "Block #1 successfully added after consensus."

Verify Policies are Active and Chain is Updated:

Give it a few seconds.

curl http://localhost:5001/status
curl http://localhost:5002/status
curl http://localhost:5003/status
curl http://localhost:5004/status


Expected: "current_policies" on all nodes should now reflect the policies:
{"restrict_sender_to_registered_orgs": true, "min_ventilator_duration_hrs": 1}.
This demonstrates on-chain governance successfully.

Step 4: Test Regular and Encrypted Transactions (NO MANUAL SIGNATURE IN CURL!)

Create a Regular Transaction (from Hospital 2 - auto-signed by Node 2's wallet):

curl -X POST -H "Content-Type: application/json" -d '{
    "sender": "Hospital_2",
    "recipient": "Hospital_1",
    "amount": 10,
    "data": {"type": "ventilator_log", "patient_id": "P001", "duration_hrs": 24}
    }' http://localhost:5002/transactions/new


Expected Logs: "Transaction added to pending...", then "Broadcasting transaction..." on Node 2. Other nodes will receive it. Node 2's logs will show "Transaction signed by Hospital_2. Simulated Signature:..."

Create an ENCRYPTED Transaction (from Hospital 3 - auto-signed by Node 3's wallet):

Simulate encryption (as before, you'd do this in your client app):
Example: simulate_encrypt(json.dumps({"type": "patient_lab_results", "patient_id": "P004", "results": "Normal"}), "Hospital_3_ENC_Key")
Yields something like: ENC:Hospital_3_ENC_Key:eyJ0eXBlIjogInBhdGllbnRfbGFiX3Jlc3VsdHMiLCAicGF0aWVudF9pZCI6ICJQMDA0IiwgInJlc3VsdHMiOiAiTm9ybWFsIn0=

curl -X POST -H "Content-Type: application/json" -d '{
    "sender": "Hospital_3",
    "recipient": "Hospital_4",
    "amount": 5,
    "data": "ENC:Hospital_3_ENC_Key:eyJ0eXBlIjogInBhdGllbnRfbGFiX3Jlc3VsdHMiLCAicGF0aWVudF9pZCI6ICJQMDA0IiwgInJlc3VsdHMiOiAiTm9ybWFsIn0=",
    "is_encrypted": true
}' http://localhost:5003/transactions/new


Expected Logs: Similar transaction added and broadcast messages. Node 3's logs will show "Transaction signed by Hospital_3. Simulated Signature:..."

Check Pending Transactions (all nodes):

curl http://localhost:5001/pending_transactions
# ... check other nodes


Expected: All nodes should now have both transactions in their pending pool, including the new signature field (a SHA-256 hash).

Step 5: Propose and Endorse Another Block (Updating World State)

Let's have Node 4 propose the next block.

Hospital_4 Proposes Block:

curl http://localhost:5004/propose_block


Expected Logs:

Node 4: "Block #2 proposed by 'Hospital_4'...", then broadcast.

Node 1, 2, 3: Receive proposal, add to proposed pool, automatically endorse, and broadcast endorsement.

All Nodes: Eventually, "Block #2 '...' received enough endorsements...", then "Block #2 successfully added after consensus."

Verify Chains and World State:

Give it a few seconds for consensus.

curl http://localhost:5001/chain
# ... check other nodes' chains


Expected: All chains should now have 3 blocks. Block #2 will contain the two transactions, including their automatically generated signatures.

curl http://localhost:5001/current_state
# ... check other nodes' states


Expected: The current_state on all nodes should now reflect the changes from the ventilator_log transaction.

Step 6: Test Data Decryption (Same as Before)

Identify Encrypted Transaction Hash:

Use curl http://localhost:5003/chain to find the encrypted transaction in Block #2 (index 2). Copy its calculate_hash() value (this is the tx_hash).

Attempt Decryption from Node 3 (which has the key):

Replace TX_HASH_OF_ENCRYPTED_TX with the actual hash you copied.

curl "http://localhost:5003/transaction/decrypt?block_index=2&tx_hash=TX_HASH_OF_ENCRYPTED_TX"


Expected: Successful decryption.

Attempt Decryption from Node 1 (which does NOT have Node 3's key):

Use the same TX_HASH_OF_ENCRYPTED_TX.

curl "http://localhost:5001/transaction/decrypt?block_index=2&tx_hash=TX_HASH_OF_ENCRYPTED_TX"


Expected: Decryption failure message, demonstrating restricted access.

Step 7: Test Policy Enforcement (On-Chain Governance) (Same as Before)

Try to Send an Unauthorized Transaction (should fail due to policy):

curl -X POST -H "Content-Type: application/json" -d '{
    "sender": "Unauthorized_Org",
    "recipient": "Hospital_1",
    "amount": 1,
    "data": {"type": "test_unauth"}
    }' http://localhost:5001/transactions/new


Expected: Policy Violation message.

This refined setup truly integrates the concept of identities and wallet-based signing into your "from scratch" consortium blockchain!


Summary of your current project structure after this change:

consortium-blockchain-project/
├── blockchain_core.py           # Core blockchain logic
├── common_node_logic.py         # Shared node functionalities
├── blockchain_node.py           # The *single* generic node launcher file
├── docker-compose.yml           # Docker orchestration
├── initial_policies.json        # Initial on-chain policies
├── start.sh                     # Script to build and run Docker
└── config/                      # Directory for node-specific configurations
    ├── node1_config.json
    ├── node2_config.json
    ├── node3_config.json
    └── node4_config.json
How to add a new hospital (e.g., Hospital_5):

Create a new config file: Add config/node5_config.json with its unique NODE_ID, NODE_PORT (e.g., 5005), and updated PEERS list including all other hospitals.
Update PEERS in all existing config files: Go into config/node1_config.json, node2_config.json, node3_config.json, node4_config.json, and the new node5_config.json and add {'id': 'Hospital_5', 'address': 'http://node5:5005'} to their PEERS lists.
Update docker-compose.yml: Add a new service block for node5, mimicking the existing ones, but pointing to config/node5_config.json and exposing port 5005. Remember to add node5 to depends_on of subsequent services if needed (e.g., node4's depends_on might need node5 if you arrange it that way, or just add it to node1).
Rebuild and run: ./start.sh